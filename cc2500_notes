Paparazzi files (proposed):
sw/airborne/peripherals/cc2500.c
sw/airborne/peripherals/cc2500.h
sw/airborne/peripherals/cc2500_regs.h
sw/airborne/subsystems/radio_control/frskyX.c
sw/airborne/subsystems/radio_control/frskyX.h
sw/airborne/subsystems/radio_control/frskyX_cc2500.c
sw/airborne/subsystems/radio_control/frskyX_cc2500.h


betaflight files:
DONE main/drivers/rx/rx_cc2500.h     --  Register defines, etc
DONE main/drivers/rx/rx_cc2500.c     --  Read, write, reset functions
DONE main/rx/cc2500_common.h         --  Init, Rssi, Tx enable/disable
DONE main/rx/cc2500_common.c         --  Init, Rssi, Tx enable/disable
main/rx/cc2500_frsky_common.h   --  FrSky init, receive, process
main/rx/cc2500_frsky_shared.h   --  FrSky enum and defines
main/rx/cc2500_frsky_shared.c   --  Init, tune, bind functions
main/rx/cc2500_frsky_x.h        --  FrSkyX init, handle, process
main/rx/cc2500_frsky_x.c        --  FrSkyX implementation
(main/pg/rx_spi_cc2500.c)         --  "Settings"


New proposal:
sw/airborne/peripherals/rx_cc2500.ch
sw/airborne/subsystems/radio_control/cc2500_xxxx.ch
sw/airborne/subsystems/radio_control/cc2500_compat.ch <-- Compatibility code
sw/airborne/subsystems/radio_control/cc2500_paparazzi.ch <-- Paparazzi-specific code
sw/airborne/subsystems/radio_control/cc2500_settings.ch  <-- Settings structs



https://github.com/betaflight/betaflight/blob/master/docs/boards/Board%20-%20CrazyBeeF4FRPro.md



Indirect calls for frsky_x:
(RX task)
rxUpdateCheck                       [Calls .rcFrameStatusFn (always). Handles signal timouts.]
--> rxRuntimeState.rcFrameStatusFn  [ptr]
--> rxSpiFrameStatus                [Calls protocolDataReceived (always), sets rxSpiNewPacketAvailable, returns status]
--> protocolDataReceived            [ptr]
--> frSkySpiDataReceived            [protocolState machine (binding). Calls handlePacket in non-binding states]
--> handlePacket                    [ptr]
--> frSkyXHandlePacket              [Very complex packet and telemetry handling]
--> buildTelemetryFrame             [// check syncronization at startup ok if not no sport telemetry]
--> appendSmartportData             [adds bytes to ringbuffer]

(fc/core.c:processRx)                   [also calls updateRssi]
(calculateRxChannelsAndUpdateFailsafe)  [If auxiliaryProcessingRequired calls .rcProcessFrame. Calls readRxChannelsApplyRanges based on timing.]
(readRxChannelsApplyRanges)             [Calls .rcReadRawFn per channel (always). Applies calibration. Sets rcRaw]
--> rxRuntimeState.rcReadRawFn          [ptr]
--> rxSpiReadRawRC                      [If rxSpiNewPacketAvailable <-- set by rxSpiFrameStatus or rxSpiProcessFrame]
--> protocolSetRcDataFromPayload        [ptr]
--> frSkySpiSetRcData                   [only calls setRcData]
--> setRcData                           [ptr]
--> frSkyXSetRcData                     [Copies from packet to rcData array]

(fc/core.c:processRx)
(calculateRxChannelsAndUpdateFailsafe)  [If auxiliaryProcessingRequired calls .rcProcessFrame. Calls readRxChannelsApplyRanges based on timing.]
--> rxRuntimeState.rcProcessFrameFn
--> rxSpiProcessFrame     [Calls protocolProcessFrame (always). Sets rxSpiNewPacketAvailable.]
--> protocolProcessFrame  [ptr]
--> frSkySpiProcessFrame  [Calls processFrame (always)]
--> processFrame          [ptr]
--> frSkyXProcessFrame    [Telemetry/smartport stuff]




Smartport notes:
processSmartPortTelemetry: <== TODO replace with own function rather than porting? Or add paparazzilink ID and keep frsky telemetry?
                           <== OR do both: keep FrSky telemetry as-is, separately call smartPortSendMessage for paparazzilink.
- Handles MSP (will do later)
- Calls smartPortSendPackage per message.
That's it.




frsky_x.c: telemetryWriteFrame, SendByte write to telemtryOutBuffer but do not actually send!

rxUpdateCheck
...
frSkyXHandlePacket (STATE_DATA) STATE_TELEMETRY? -> contains delay in event function!
==> buildTelemetryFrame   // check syncronization at startup ok if not no sport telemetry
==> appendSmartportData

IDEA: move receiver code to periodic function with correct frequency?




Trace telemetry from writeFifo:
(rcFrameStatusFn, see above)
...
--> frSkyXHandlePacket
--> cc2500WriteFifo       [Is actually reached already...]




Are all telemetry functions called?
cc2500_frsky_x.c:
  bool telemetryEnabled <= initSmartPortTelemetryExternal <= true or false TODO check
  calculateCrc <= buildTelemetryFrame, isValidPacket
  appendSmartPortData <= buildTelemetryFrame
  buildTelemetryFrame <= frSkyXHandlePacket
  frSkyXReadyToSend <= frSkyXProcessFrame
  frSkyXTelemetrySendByte <= frSkyXTelemetryWriteFrame
  frSkyXTelemetryWriteFrame <= frSkyXInit (arg to initSmartPortTelemetryExternal)
  isValidPacket <= frSkyXHandlePacket
  frSkyXHandlePacket <= frSkySpiInit (handlepacket = )
  frSkyXProcessFrame <= frSkySpiInit (processFrame = )
  frSkySpiXInit <= frSkySpiInit
cc2500_frsky_shared.c:
  handlePacket <= frSkySpiDataReceived
  frSkySpiDataReceived <= rxSpiSetProtocol (protocolDataReceived = )
  processFrame <= frSkySpiProcessFrame
  frSkySpiProcessFrame <= rxSpiSetProtocol (protocolProcessFrame = )
cc2500_rx_spi.c:
  rxSpiSetProtocol <= rxSpiInit
  protocolDataReceived <= rxSpiFrameStatus
  rxSpiFrameStatus <= rxSpiInit (rxRuntimeState->rcFrameStatusFn = )
  protocolProcessFrame <= rxSpiProcessFrame
  rxSpiProcessFrame <= rxSpiInit (rxRuntimeState->rcProcessFrameFn = )
cc2500_rx.c:
  rxInit <= radio_control_impl_init
  rxRuntimeState.rcFrameStatusFn <= radio_control_impl_event
  rxRuntimeState.rcProcessFrameFn <= radio_control_impl_event
cc2500_smartport.c:
  smartPortDataReceive <= frSkyXProcessFrame
  smartPortSendPackage <= processSmartPortTelemetry
  processSmartPortTelemetry <= frSkyXProcessFrame
  initSmartPortSensors <= initSmartPortTelemetryExternal
  initSmartPortTelemetryExternal <= frSkyXInit



handleSmartPortTelemetry is called by telemetry task in betaflight, but not in paparazzi!
Same for initSmartPortTelemetry
Maybe serial port needs to be initialized anyway, even though it is not used.
Check out  betaflight/src/main/telemetry/telemetry.c  which is not ported right now...


Why is there no telemetry stream?
cc2500_frsky_x.c::frSkyXTelemetrySendByte is called
cc2500_frsky_x.c::appendSmartPortData NOT CALLED, NOT WRITING
cc2500_frsky_x.c::buildTelemetryFrame (TX in Telem OFF mode, also during sensor discovery)
    ONLY CASE 1 CALLED ( if (inFrameMarker->data.initRequest) )
    CASE 3 called ONCE
cc2500_frsky_x.c::buildTelemetryFrame (TX in Telem ON mode, also during sensor discovery)
    ONLY CASE 1 CALLED ( if (inFrameMarker->data.initRequest) )
cc2500_frsky_x.c::buildTelemetryFrame (case 1 disabled, TX in Telem OFF/ON mode, also during sensor discovery)
    CASE 3 CALLED ONLY ONCE
cc2500_frsky_x.c::buildTelemetryFrame (force case 3 without checks)
    Telemetry stream present, but not received. No response in TX request byte.


Removing debug downlink does not fix telemetry



frsky_x.c::frSkyXHandlePacket timing:
STATE_STARTING
  ==> STATE_UPDATE

STATE_UPDATE
  packetTimerUs = micros()
  ==> STATE_DATA
  receiveDelayUs = 5300
  if SpiBindRequested
    packetTimerUs = 0
    timeoutUs = 50
    missingPackets = 0
    ==> STATE_INIT
  !FALLTHROUGH!

STATE_DATA
  if GDO and !frameReceived
    ReadFifo
    if isValidPacket
      missingPackets = 0
      timeoutUs = 1
      receiveDelayUs = 0
      telemetryReceived = true
      packetTimerUs = micros()
      frameReceived = true
    if !frameReceived
      SFRX
  if telemetryReceived
    if micros() > packetTimerUs + receiveDelayUs
      ==> STATE_TELEMETRY
      buildTelemetryFrame
  if micros() > packetTimerUs + timeoutUs * SYNC_DELAY_MAX (9000)
    SpiLedToggle
    Rssi 0
    ==> STATE_UPDATE
  if frameReceived
    ret |= RX_SPI_RECEIVED_DATA

STATE_TELEMETRY
  if micros() > packetTimerUs (STATE_UPDATE) + receiveDelayUs (0 if valid packet received, 5300 otherwise) + telemetryDelayUs (1400 for LBT)
    SFRX
    WriteFifo
    if telemetryEnabled
      ret |= RX_SPI_PROCESSING_REQUIRED
    ==> STATE_RESUME

STATE_RESUME
  if micros() > packetTimerUs + receiveDelayUs (0 or 5300) + 3700
    packetTimerUs = micros()
    receiveDelay = 5300
    frameReceived = false
    if missingPackets > MAX_MISSING_PKT
      timeoutUs = 50
      telemetryReceived = false
      ==> STATE_UPDATE
      !BREAK!
    missingPackets++
    ==> STATE_DATA


State entry times:
packetTimerUs + 100-150 (Required: < 6700): STATE_TELEMETRY *first entry*
packetTimerUs + 1700-1800 (Required: < 9000): STATE_RESUME *first entry*
Both of the times show occasional spikes

If-block entry times:
packetTimerUs + ~1405, sometimes ~6711: STATE_TELEMETRY
packetTimerUs + ~3712, sometimes ~9011: STATE_RESUME
